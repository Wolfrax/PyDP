1: primary_expression ::= ID | CONSTANT | STRING_LITERAL | "(" expression ")"

2: postfix_expression ::= primary_expression | postfix_expression "[" expression "]" | postfix_expression "(" ")" | postfix_expression "(" argument_expression_list ")" | postfix_expression "." ID | postfix_expression POINTER ID | postfix_expression INCR | postfix_expression DECR 

3: argument_expression_list ::= assignment_expression | argument_expression_list "," assignment_expression 

4: unary_expression ::= postfix_expression | INCR unary_expression | DECR unary_expression | unary_operator cast_expression | SIZEOF unary_expression | SIZEOF "(" type_name ")" 

5: unary_operator ::= "&" | "*" | "+" | "-" | "~" | "!"

6: cast_expression ::= unary_expression | "(" type_name ")" cast_expression

7: multiplicative_expression ::= cast_expression | multiplicative_expression "*" cast_expression | multiplicative_expression "/" cast_expression | multiplicative_expression "%" cast_expression 

8: additive_expression ::= multiplicative_expression | additive_expression "+" multiplicative_expression | additive_expression "-" multiplicative_expression 

9: shift_expression ::= additive_expression | shift_expression SHIFT_LEFT additive_expression | shift_expression SHIFT_RIGHT additive_expression 

10: relational_expression ::= shift_expression | relational_expression "<" shift_expression | relational_expression ">" shift_expression | relational_expression LE shift_expression | relational_expression GE shift_expression

11: equality_expression ::= relational_expression | equality_expression EQ relational_expression | equality_expression NE relational_expression 

12: and_expression ::= equality_expression | and_expression "&" equality_expression 

13: exclusive_or_expression ::= and_expression | exclusive_or_expression "^" and_expression 

14: inclusive_or_expression ::= exclusive_or_expression | inclusive_or_expression "|" exclusive_or_expression 

15: logical_and_expression ::= inclusive_or_expression | logical_and_expression AND inclusive_or_expression 

16: logical_or_expression ::= logical_and_expression | logical_or_expression OR logical_and_expression 

17: conditional_expression ::= logical_or_expression | logical_or_expression "?" expression ":" conditional_expression 

18: assignment_expression ::= conditional_expression | unary_expression assignment_operator assignment_expression

19: assignment_operator ::= "=" | ASSIGN_TIMES | ASSIGN_DIVIDE | ASSIGN_MOD | ASSIGN_PLUS | ASSIGN_MINUS | ASSIGN_LEFT | ASSIGN_RIGHT | ASSIGN_AND | ASSIGN_XOR | ASSIGN_OR 

20: expression ::= assignment_expression | assignment_expression ","

21: assignment_expression_list ::= assignment_expression delim

22: delim ::= ","

23: constant_expression ::= conditional_expression

24: declaration ::= declaration_specifiers ";" | declaration_specifiers init_declarator_list ";" 

25: declaration_specifiers ::= storage_class_specifier | storage_class_specifier declaration_specifiers | type_specifier | type_specifier declaration_specifiers | type_qualifier | type_qualifier declaration_specifiers

26: init_declarator_list ::= init_declarator

27: init_declarator ::= declarator | declarator "=" initializer

28: pre_kr_initializer ::= CONSTANT | expression

29: pre_kr_constant_expression_list ::= pre_kr_constant_expression | pre_kr_constant_expression "," pre_kr_constant_expression_list 

30: pre_kr_constant_expression ::= expression

31: pre_kr_constant_expression ::= expression "," assignment_expression

32: storage_class_specifier ::= TYPEDEF | EXTERN | STATIC | AUTO | REG

33: type_specifier ::= VOID | CHAR | SHORT | INT | LONG | FLOAT | DOUBLE | SIGNED | UNSIGNED | struct_or_union_specifier | enum_specifier | typedef_name 

34: struct_or_union_specifier ::= struct_or_union ID "{" struct_declaration_list "}" | struct_or_union "{" struct_declaration_list "}" | struct_or_union ID 

35: struct_or_union ::= STRUCT | UNION

36: struct_declaration_list ::= struct_declaration | struct_declaration_list struct_declaration 

37: struct_declaration ::= specifier_qualifier_list struct_declarator_list ";"

38: specifier_qualifier_list ::= type_specifier specifier_qualifier_list | type_specifier | type_qualifier specifier_qualifier_list | type_qualifier 

39: struct_declarator_list ::= struct_declarator | struct_declarator_list "," struct_declarator

40: struct_declarator ::= declarator | ":" constant_expression | declarator ":" constant_expression 

41: enum_specifier ::= ENUM "{" enumerator_list "}" | ENUM ID "{" enumerator_list "}" | ENUM ID 

42: enumerator_list ::= enumerator | enumerator_list "," enumerator

43: enumerator ::= ID | ID "=" constant_expression

44: type_qualifier ::= CONST | VOLATILE

45: declarator ::= pointer direct_declarator | direct_declarator 

46: direct_declarator ::= ID | "(" declarator ")" | direct_declarator "[" constant_expression "]" | direct_declarator "[" "]" | direct_declarator "(" parameter_type_list ")" | direct_declarator "(" identifier_list ")" | direct_declarator "(" ")" 

47: pointer ::= "*" | "*" type_qualifier_list | "*" pointer | "*" type_qualifier_list pointer 

48: type_qualifier_list ::= type_qualifier | type_qualifier_list type_qualifier

49: parameter_type_list ::= parameter_list | parameter_list "," ELLIPSIS

50: parameter_list ::= parameter_declaration | parameter_list "," parameter_declaration 

51: parameter_declaration ::= declaration_specifiers declarator | declaration_specifiers abstract_declarator | declaration_specifiers 

52: identifier_list ::= ID | identifier_list "," ID 

53: type_name ::= specifier_qualifier_list | specifier_qualifier_list abstract_declarator 

54: abstract_declarator ::= pointer | direct_abstract_declarator | pointer direct_abstract_declarator 

55: direct_abstract_declarator ::= "(" abstract_declarator ")" | "[" "]" | "[" constant_expression "]" | direct_abstract_declarator "[" "]" | direct_abstract_declarator "[" constant_expression "]" | "(" ")" | "(" parameter_type_list ")" | direct_abstract_declarator "(" ")" | direct_abstract_declarator "(" parameter_type_list ")" 

56: typedef_name ::= TYPE_NAME

57: initializer ::= assignment_expression | "{" initializer_list "}" | "{" initializer_list "," "}" 

58: initializer_list ::= initializer | initializer_list "," initializer 

59: statement ::= labeled_statement | compound_statement | expression_statement | selection_statement | iteration_statement | jump_statement 

60: labeled_statement ::= ID ":" statement | CASE constant_expression ":" statement | DEFAULT ":" statement 

61: compound_statement ::= "{" "}" | "{" statement_list "}" | "{" declaration_list "}" | "{" declaration_list statement_list "}" 

62: declaration_list ::= declaration | declaration_list declaration 

63: statement_list ::= statement | statement_list statement 

64: expression_statement ::= ";" | expression ";" 

65: selection_statement ::= IF "(" expression ")" statement %prec THEN | IF "(" expression ")" statement ELSE statement | SWITCH "(" expression ")" statement

66: iteration_statement ::= WHILE "(" expression ")" statement | DO statement WHILE "(" expression ")" ";" | FOR "(" expression_statement expression_statement ")" statement | FOR "(" expression_statement expression_statement expression ")" statement 

67: jump_statement ::= GOTO ID ";" | CONTINUE ";" | BREAK ";" | RETURN ";" | RETURN expression ";" 

68: translation_unit ::= external_declaration | translation_unit external_declaration 

69: external_declaration ::= function_definition | declaration 

70: function_definition ::= declaration_specifiers declarator declaration_list compound_statement | declaration_specifiers declarator compound_statement | declarator declaration_list compound_statement | declarator compound_statement 

