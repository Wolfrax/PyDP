Grammar:

Rule 0     S' -> translation_unit
Rule 1     translation_unit -> type_specifier ;
Rule 2     type_specifier -> struct_specifier
Rule 3     type_specifier -> UNSIGNED
Rule 4     type_specifier -> SIGNED
Rule 5     type_specifier -> DOUBLE
Rule 6     type_specifier -> FLOAT
Rule 7     type_specifier -> LONG
Rule 8     type_specifier -> INT
Rule 9     type_specifier -> SHORT
Rule 10    type_specifier -> CHAR
Rule 11    type_specifier -> VOID
Rule 12    struct_specifier -> STRUCT ID variable initializer
Rule 13    variable -> ID
Rule 14    initializer -> { initializer_list }
Rule 15    initializer_list -> initializer_list , expression
Rule 16    initializer_list -> expression
Rule 17    expression -> CONSTANT
Rule 18    expression -> ID

Unused terminals:

    WHILE
    CONST
    ASSIGN_PLUS
    EXTERN
    RETURN
    IF
    TYPE_NAME
    ASSIGN_OR
    GOTO
    DEFAULT
    SHIFT_LEFT
    TYPEDEF
    STRING_LITERAL
    REG
    SWITCH
    ELLIPSIS
    ELSE
    AND
    OR
    CASE
    EQ
    POINTER
    SIZEOF
    ASSIGN_DIVIDE
    ASSIGN_MOD
    UNION
    ASSIGN_MINUS
    GE
    NE
    ASSIGN_RIGHT
    ASSIGN_XOR
    ENUM
    FOR
    ASSIGN_LEFT
    BREAK
    ASSIGN_AND
    INCR
    LE
    AUTO
    DECR
    VOLATILE
    CONTINUE
    DO
    ASSIGN_TIMES
    STATIC
    SHIFT_RIGHT

Terminals, with rules where they appear:

,                    : 15
;                    : 1
AND                  : 
ASSIGN_AND           : 
ASSIGN_DIVIDE        : 
ASSIGN_LEFT          : 
ASSIGN_MINUS         : 
ASSIGN_MOD           : 
ASSIGN_OR            : 
ASSIGN_PLUS          : 
ASSIGN_RIGHT         : 
ASSIGN_TIMES         : 
ASSIGN_XOR           : 
AUTO                 : 
BREAK                : 
CASE                 : 
CHAR                 : 10
CONST                : 
CONSTANT             : 17
CONTINUE             : 
DECR                 : 
DEFAULT              : 
DO                   : 
DOUBLE               : 5
ELLIPSIS             : 
ELSE                 : 
ENUM                 : 
EQ                   : 
EXTERN               : 
FLOAT                : 6
FOR                  : 
GE                   : 
GOTO                 : 
ID                   : 12 13 18
IF                   : 
INCR                 : 
INT                  : 8
LE                   : 
LONG                 : 7
NE                   : 
OR                   : 
POINTER              : 
REG                  : 
RETURN               : 
SHIFT_LEFT           : 
SHIFT_RIGHT          : 
SHORT                : 9
SIGNED               : 4
SIZEOF               : 
STATIC               : 
STRING_LITERAL       : 
STRUCT               : 12
SWITCH               : 
TYPEDEF              : 
TYPE_NAME            : 
UNION                : 
UNSIGNED             : 3
VOID                 : 11
VOLATILE             : 
WHILE                : 
error                : 
{                    : 14
}                    : 14

Nonterminals, with rules where they appear:

expression           : 15 16
initializer          : 12
initializer_list     : 14 15
struct_specifier     : 2
translation_unit     : 0
type_specifier       : 1
variable             : 12


state 0

    (0) S' -> . translation_unit
    (1) translation_unit -> . type_specifier ;
    (2) type_specifier -> . struct_specifier
    (3) type_specifier -> . UNSIGNED
    (4) type_specifier -> . SIGNED
    (5) type_specifier -> . DOUBLE
    (6) type_specifier -> . FLOAT
    (7) type_specifier -> . LONG
    (8) type_specifier -> . INT
    (9) type_specifier -> . SHORT
    (10) type_specifier -> . CHAR
    (11) type_specifier -> . VOID
    (12) struct_specifier -> . STRUCT ID variable initializer
    UNSIGNED        shift and go to state 4
    SIGNED          shift and go to state 5
    DOUBLE          shift and go to state 6
    FLOAT           shift and go to state 7
    LONG            shift and go to state 8
    INT             shift and go to state 9
    SHORT           shift and go to state 10
    CHAR            shift and go to state 11
    VOID            shift and go to state 12
    STRUCT          shift and go to state 13

    translation_unit               shift and go to state 1
    type_specifier                 shift and go to state 2
    struct_specifier               shift and go to state 3

state 1

    (0) S' -> translation_unit .


state 2

    (1) translation_unit -> type_specifier . ;
    ;               shift and go to state 14


state 3

    (2) type_specifier -> struct_specifier .
    ;               reduce using rule 2 (type_specifier -> struct_specifier .)


state 4

    (3) type_specifier -> UNSIGNED .
    ;               reduce using rule 3 (type_specifier -> UNSIGNED .)


state 5

    (4) type_specifier -> SIGNED .
    ;               reduce using rule 4 (type_specifier -> SIGNED .)


state 6

    (5) type_specifier -> DOUBLE .
    ;               reduce using rule 5 (type_specifier -> DOUBLE .)


state 7

    (6) type_specifier -> FLOAT .
    ;               reduce using rule 6 (type_specifier -> FLOAT .)


state 8

    (7) type_specifier -> LONG .
    ;               reduce using rule 7 (type_specifier -> LONG .)


state 9

    (8) type_specifier -> INT .
    ;               reduce using rule 8 (type_specifier -> INT .)


state 10

    (9) type_specifier -> SHORT .
    ;               reduce using rule 9 (type_specifier -> SHORT .)


state 11

    (10) type_specifier -> CHAR .
    ;               reduce using rule 10 (type_specifier -> CHAR .)


state 12

    (11) type_specifier -> VOID .
    ;               reduce using rule 11 (type_specifier -> VOID .)


state 13

    (12) struct_specifier -> STRUCT . ID variable initializer
    ID              shift and go to state 15


state 14

    (1) translation_unit -> type_specifier ; .
    $end            reduce using rule 1 (translation_unit -> type_specifier ; .)


state 15

    (12) struct_specifier -> STRUCT ID . variable initializer
    (13) variable -> . ID
    ID              shift and go to state 16

    variable                       shift and go to state 17

state 16

    (13) variable -> ID .
    {               reduce using rule 13 (variable -> ID .)


state 17

    (12) struct_specifier -> STRUCT ID variable . initializer
    (14) initializer -> . { initializer_list }
    {               shift and go to state 19

    initializer                    shift and go to state 18

state 18

    (12) struct_specifier -> STRUCT ID variable initializer .
    ;               reduce using rule 12 (struct_specifier -> STRUCT ID variable initializer .)


state 19

    (14) initializer -> { . initializer_list }
    (15) initializer_list -> . initializer_list , expression
    (16) initializer_list -> . expression
    (17) expression -> . CONSTANT
    (18) expression -> . ID
    CONSTANT        shift and go to state 22
    ID              shift and go to state 23

    initializer_list               shift and go to state 20
    expression                     shift and go to state 21

state 20

    (14) initializer -> { initializer_list . }
    (15) initializer_list -> initializer_list . , expression
    }               shift and go to state 24
    ,               shift and go to state 25


state 21

    (16) initializer_list -> expression .
    }               reduce using rule 16 (initializer_list -> expression .)
    ,               reduce using rule 16 (initializer_list -> expression .)


state 22

    (17) expression -> CONSTANT .
    }               reduce using rule 17 (expression -> CONSTANT .)
    ,               reduce using rule 17 (expression -> CONSTANT .)


state 23

    (18) expression -> ID .
    }               reduce using rule 18 (expression -> ID .)
    ,               reduce using rule 18 (expression -> ID .)


state 24

    (14) initializer -> { initializer_list } .
    ;               reduce using rule 14 (initializer -> { initializer_list } .)


state 25

    (15) initializer_list -> initializer_list , . expression
    (17) expression -> . CONSTANT
    (18) expression -> . ID
    CONSTANT        shift and go to state 22
    ID              shift and go to state 23

    expression                     shift and go to state 26

state 26

    (15) initializer_list -> initializer_list , expression .
    }               reduce using rule 15 (initializer_list -> initializer_list , expression .)
    ,               reduce using rule 15 (initializer_list -> initializer_list , expression .)
